# Passo a Passo para Criar uma API REST com Spring Boot, MySQL e DTOs

## Passo 1: Configuração inicial do projeto

1. Criar um projeto Spring Boot usando Spring Initializr (https://start.spring.io/)
   - Project: Maven
   - Language: Java
   - Spring Boot: 3.4.5
   - Group: com.example.api
   - Artifact: demo
   - Name: demo
   - Description: Demo project for Spring Boot
   - Package name: com.example.api.demo
   - Packaging: Jar
   - Java: 21
   - Dependencies: 
     - Spring Web
     - Spring Data JPA
     - MySQL Driver
     - Spring Boot DevTools

2. Baixar o projeto gerado e extrair em seu diretório preferido

## Passo 2: Configuração do Banco de Dados MySQL

1. Criar arquivo docker-compose.yml na raiz do projeto para facilitar a configuração do MySQL:
services:
  mysql:
    image: mysql:9.3.0
    container_name: api_rest_mysql
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: {Sua_senha_root}
      MYSQL_DATABASE: api_rest_db
      MYSQL_USER: api_user
      MYSQL_PASSWORD: {Sua_senha_usuario}
    ports:
      - "3306:3306"
    volumes:
      - mysql_data:/var/lib/mysql
    networks:
      - api_network

volumes:
  mysql_data:

networks:
  api_network:
    driver: bridge

2. Iniciar o contêiner MySQL: (No terminal da raiz do projeto)
   docker-compose up -d   

3. Configurar arquivo application.properties em src/main/resources/
# DataSource Configuration (MySQL)
spring.datasource.url=jdbc:mysql://localhost:3306/api_rest_db
spring.datasource.username=api_user
spring.datasource.password={Sua_senha_usuario}
spring.datasource.driverClassName=com.mysql.cj.jdbc.Driver

# JPA/Hibernate
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQLDialect

## Passo 3: Criar a Estrutura de Pacotes

1. Organizar os seguintes pacotes:
   - com.example.api.demo.model
   - com.example.api.demo.dto
   - com.example.api.demo.repository
   - com.example.api.demo.service
   - com.example.api.demo.controller
   - com.example.api.demo.config

## Passo 4: Criar o Modelo da Entidade

1. Criar a classe Produto.java no pacote model:
package com.example.api.demo.model;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;

@Entity
public class Produto {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String nome;
    private String descricao;
    private Double preco;
    private Integer quantidade;

    public Produto() {}

    public Produto(Long id, String nome, String descricao, Double preco, Integer quantidade) {
        this.id = id;
        this.nome = nome;
        this.descricao = descricao;
        this.preco = preco;
        this.quantidade = quantidade;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getNome() {
        return nome;
    }

    public void setNome(String nome) {
        this.nome = nome;
    }

    public String getDescricao() {
        return descricao;
    }

    public void setDescricao(String descricao) {
        this.descricao = descricao;
    }

    public Double getPreco() {
        return preco;
    }

    public void setPreco(Double preco) {
        this.preco = preco;
    }

    public Integer getQuantidade() {
        return quantidade;
    }

    public void setQuantidade(Integer quantidade) {
        this.quantidade = quantidade;
    }
}

## Passo 5: Criar o DTO (Data Transfer Object)

1. Criar a classe ProdutoDTO.java no pacote dto:
package com.example.api.demo.dto;

public class ProdutoDTO {
    
    private Long id;
    private String nome;
    private String descricao;
    private Double preco;
    private Integer quantidade;
    
    // Construtores
    public ProdutoDTO() {}
    
    public ProdutoDTO(Long id, String nome, String descricao, Double preco, Integer quantidade) {
        this.id = id;
        this.nome = nome;
        this.descricao = descricao;
        this.preco = preco;
        this.quantidade = quantidade;
    }

    // Getters e Setters
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getNome() {
        return nome;
    }

    public void setNome(String nome) {
        this.nome = nome;
    }

    public String getDescricao() {
        return descricao;
    }

    public void setDescricao(String descricao) {
        this.descricao = descricao;
    }

    public Double getPreco() {
        return preco;
    }

    public void setPreco(Double preco) {
        this.preco = preco;
    }

    public Integer getQuantidade() {
        return quantidade;
    }

    public void setQuantidade(Integer quantidade) {
        this.quantidade = quantidade;
    }
}

## Passo 6: Criar o Repository

1. Criar a interface ProdutoRepository.java no pacote repository:
package com.example.api.demo.repository;

import com.example.api.demo.model.Produto;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface ProdutoRepository extends JpaRepository<Produto, Long> {
    // JpaRepository já fornece métodos básicos como save, findById, findAll, delete, etc.
}

## Passo 7: Criar o Service

1. Criar a classe ProdutoService.java no pacote service:
package com.example.api.demo.service;

import com.example.api.demo.dto.ProdutoDTO;
import com.example.api.demo.model.Produto;
import com.example.api.demo.repository.ProdutoRepository;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
public class ProdutoService {
    
    private final ProdutoRepository produtoRepository;
    
    // Constructor injection
    public ProdutoService(ProdutoRepository produtoRepository) {
        this.produtoRepository = produtoRepository;
    }
    
    /**
     * Converter Produto para ProdutoDTO
     */
    private ProdutoDTO convertToDTO(Produto produto) {
        return new ProdutoDTO(
            produto.getId(),
            produto.getNome(),
            produto.getDescricao(),
            produto.getPreco(),
            produto.getQuantidade()
        );
    }
    
    /**
     * Converter ProdutoDTO para Produto
     */
    private Produto convertToEntity(ProdutoDTO produtoDTO) {
        Produto produto = new Produto();
        produto.setId(produtoDTO.getId());
        produto.setNome(produtoDTO.getNome());
        produto.setDescricao(produtoDTO.getDescricao());
        produto.setPreco(produtoDTO.getPreco());
        produto.setQuantidade(produtoDTO.getQuantidade());
        return produto;
    }
    
    /**
     * Listar todos os produtos
     */
    public List<ProdutoDTO> listarTodos() {
        return produtoRepository.findAll()
            .stream()
            .map(this::convertToDTO)
            .collect(Collectors.toList());
    }
    
    /**
     * Buscar produto por ID
     */
    public Optional<ProdutoDTO> buscarPorId(Long id) {
        return produtoRepository.findById(id)
            .map(this::convertToDTO);
    }
    
    /**
     * Criar novo produto
     */
    public ProdutoDTO criar(ProdutoDTO produtoDTO) {
        Produto produto = convertToEntity(produtoDTO);
        Produto produtoSalvo = produtoRepository.save(produto);
        return convertToDTO(produtoSalvo);
    }
    
    /**
     * Atualizar produto existente
     */
    public Optional<ProdutoDTO> atualizar(Long id, ProdutoDTO produtoDTO) {
        if (!produtoRepository.existsById(id)) {
            return Optional.empty();
        }
        
        Produto produto = convertToEntity(produtoDTO);
        produto.setId(id);
        Produto produtoAtualizado = produtoRepository.save(produto);
        return Optional.of(convertToDTO(produtoAtualizado));
    }
    
    /**
     * Excluir produto
     */
    public boolean excluir(Long id) {
        if (!produtoRepository.existsById(id)) {
            return false;
        }
        
        produtoRepository.deleteById(id);
        return true;
    }
}

## Passo 8: Criar o Controller (Com DTO)

1. Criar a classe ProdutoController.java no pacote controller:
package com.example.api.demo.controller;

import java.util.List;
import java.util.Optional;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;

import com.example.api.demo.dto.ProdutoDTO;
import com.example.api.demo.service.ProdutoService;

@RestController
@RequestMapping("/api/produtos")
public class ProdutoController {
    
    private final ProdutoService produtoService;
    
    // Constructor injection
    public ProdutoController(ProdutoService produtoService) {
        this.produtoService = produtoService;
    }

    // Listar todos os produtos
    @GetMapping
    public List<ProdutoDTO> listarTodos() {
        return produtoService.listarTodos();
    }
    
    @GetMapping("/{id}")
    public ResponseEntity<ProdutoDTO> obterPorId(@PathVariable Long id) {
        Optional<ProdutoDTO> produto = produtoService.buscarPorId(id);
        
        return produto
            .map(ResponseEntity::ok)
            .orElse(ResponseEntity.notFound().build());
    }

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public ProdutoDTO adicionar(@RequestBody ProdutoDTO produtoDTO) {
        return produtoService.criar(produtoDTO);
    }
    
    @PutMapping("/{id}")
    public ResponseEntity<ProdutoDTO> atualizar(@PathVariable Long id, @RequestBody ProdutoDTO produtoDTO) {
        Optional<ProdutoDTO> produtoAtualizado = produtoService.atualizar(id, produtoDTO);
        
        return produtoAtualizado
            .map(ResponseEntity::ok)
            .orElse(ResponseEntity.notFound().build());
    } 

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> remover(@PathVariable Long id) {
        boolean excluido = produtoService.excluir(id);
        
        if (excluido) {
            return ResponseEntity.noContent().build();
        } else {
            return ResponseEntity.notFound().build();
        }
    }
}

## Passo 9 (Opcional): Criar Controller Alternativo sem DTO

1. Criar um arquivo de exemplo "ControllersemDTO.txt" para referência:
package com.example.api.demo.controller;

import com.example.api.demo.model.Produto;
import com.example.api.demo.repository.ProdutoRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Optional;

@RestController
@RequestMapping("/api/produtos")
public class ProdutoController {

    @Autowired
    private ProdutoRepository produtoRepository;

    // Listar todos os produtos
    @GetMapping
    public List<Produto> listarTodos() {
        return produtoRepository.findAll();
    }

    // Obter um produto específico
    @GetMapping("/{id}")
    public ResponseEntity<Produto> obterPorId(@PathVariable Long id) {
        Optional<Produto> produto = produtoRepository.findById(id);
        
        if (produto.isPresent()) {
            return ResponseEntity.ok(produto.get());
        } else {
            return ResponseEntity.notFound().build();
        }
    }

    // Criar um novo produto
    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public Produto adicionar(@RequestBody Produto produto) {
        return produtoRepository.save(produto);
    }

    // Atualizar um produto existente
    @PutMapping("/{id}")
    public ResponseEntity<Produto> atualizar(@PathVariable Long id, @RequestBody Produto produto) {
        if (!produtoRepository.existsById(id)) {
            return ResponseEntity.notFound().build();
        }
        
        produto.setId(id);
        Produto produtoAtualizado = produtoRepository.save(produto);
        return ResponseEntity.ok(produtoAtualizado);
    }

    // Remover um produto
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> remover(@PathVariable Long id) {
        if (!produtoRepository.existsById(id)) {
            return ResponseEntity.notFound().build();
        }
        
        produtoRepository.deleteById(id);
        return ResponseEntity.noContent().build();
    }
}

## Passo 10: Configuração do Banco de Dados (Opcional)

1. Criar a classe SqlServerConfig.java no pacote config para demonstração de configuração específica:
package com.example.api.demo.config;

import javax.sql.DataSource;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.datasource.DriverManagerDataSource;
import org.springframework.orm.jpa.JpaVendorAdapter;
import org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;

@Configuration
public class SqlServerConfig {
    
    @Value("${spring.datasource.url}")
    private String dataSourceUrl;
    
    @Value("${spring.datasource.driverClassName}")
    private String driverClassName;
    
    @Value("${spring.datasource.username}")
    private String username;
    
    @Value("${spring.datasource.password}")
    private String password;
    
    @Bean
    public DataSource dataSource() {
        DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setDriverClassName(driverClassName);
        dataSource.setUrl(dataSourceUrl);
        dataSource.setUsername(username);
        dataSource.setPassword(password);
        return dataSource;
    }
    
    @Bean
    public JpaVendorAdapter jpaVendorAdapter() {
        HibernateJpaVendorAdapter adapter = new HibernateJpaVendorAdapter();
        adapter.setShowSql(true);
        adapter.setGenerateDdl(true);
        adapter.setDatabasePlatform("org.hibernate.dialect.MySQLDialect");
        return adapter;
    }
}

## Passo 11: Classe Principal da Aplicação

1. A classe DemoApplication.java já deve existir no pacote principal:
package com.example.api.demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class DemoApplication {

    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
}

## Passo 12: Testar a API

1. Iniciar a aplicação:
mvn spring-boot:run

2. Usar Hoppscotch para testar os endpoints da API:

   Endpoints para teste:
   - GET http://localhost:8080/api/produtos
     * Descrição: Lista todos os produtos cadastrados
     * Resposta esperada: Array JSON com todos os produtos

   - GET http://localhost:8080/api/produtos/1
     * Descrição: Busca um produto pelo ID
     * Resposta esperada: Objeto JSON do produto ou 404 Not Found

   - POST http://localhost:8080/api/produtos
     * Content-Type: application/json
     * Body:
       ```json
       {
         "nome": "Produto Teste",
         "descricao": "Descrição do produto teste",
         "preco": 99.90,
         "quantidade": 10
       }
       ```
     * Descrição: Cadastra um novo produto
     * Resposta esperada: Objeto JSON com o produto criado (status 201)

   - PUT http://localhost:8080/api/produtos/1
     * Content-Type: application/json
     * Body:
       ```json
       {
         "nome": "Produto Atualizado",
         "descricao": "Descrição do produto atualizada",
         "preco": 199.90,
         "quantidade": 20
       }
       ```
     * Descrição: Atualiza um produto existente pelo ID
     * Resposta esperada: Objeto JSON com o produto atualizado ou 404 Not Found

   - DELETE http://localhost:8080/api/produtos/1
     * Descrição: Remove um produto pelo ID
     * Resposta esperada: 204 No Content ou 404 Not Found

3. Dicas para utilizar o Hoppscotch:
   - Acesse https://hoppscotch.io ou utilize a versão desktop
   - Configure a URL base como http://localhost:8080
   - Utilize a interface para definir o método HTTP, parâmetros e corpo da requisição
   - Para endpoints com corpo JSON, selecione o tipo "application/json"
   - Verifique os códigos de status e o corpo das respostas para validar o funcionamento

## Conclusão
Este passo a passo demonstra a criação de uma API REST completa com Spring Boot, utilizando o 
padrão DTO para separar a representação externa dos dados do modelo interno, com persistência em banco de dados MySQL. 
A estrutura organizada em camadas (controller, service, repository, model) facilita a manutenção e evolução do código.